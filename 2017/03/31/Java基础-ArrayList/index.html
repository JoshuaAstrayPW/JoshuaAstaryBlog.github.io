<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="start from zero">
    

    <!--Author-->
    
        <meta name="author" content="Joshua">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Java基础:ArrayList"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="start from zero" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="JoshuaAstray&#39;Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Java基础:ArrayList - JoshuaAstray&#39;Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Home</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/JoshuaAstrayPW">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Java基础:ArrayList</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2017-03-31
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Java基础，集合/">#Java基础，集合</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="一·ArrayList概述"><a href="#一·ArrayList概述" class="headerlink" title="一·ArrayList概述"></a>一·ArrayList概述</h3><p>ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
<p>   每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p>
<p>   注意，ArrayList实现<strong>不是同步</strong>的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：</p>
<p><strong>List list = Collections.synchronizedList(new ArrayList(…));</strong> </p>
<h3 id="二·ArrayList源码分析"><a href="#二·ArrayList源码分析" class="headerlink" title="二·ArrayList源码分析"></a>二·ArrayList源码分析</h3><h4 id="2-1底层使用数组"><a href="#2-1底层使用数组" class="headerlink" title="2.1底层使用数组"></a>2.1底层使用数组</h4><pre><code>private transient Object[] elementData; 
</code></pre><p>transient为java关键字，为变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。</p>
<p>   这里Object[] elementData，就是我们的ArrayList容器，下面介绍的基本操作都是基于该elementData变量来进行操作的。 </p>
<h4 id="2-2构造函数"><a href="#2-2构造函数" class="headerlink" title="2.2构造函数"></a>2.2构造函数</h4><p>ArrayList提供了三个构造函数：</p>
<p>  ArrayList()：默认构造函数，提供初始容量为10的空列表。</p>
<p>  ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。</p>
<p>  ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 </p>
<pre><code>  /**
 * 构造一个初始容量为 10 的空列表
 */
public ArrayList() {
    this(10);
}

/**
 * 构造一个具有指定初始容量的空列表。
 */
public ArrayList(int initialCapacity) {
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;
                + initialCapacity);
    this.elementData = new Object[initialCapacity];
}

/**
 *  构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。
 */
public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    size = elementData.length;
    // c.toArray might (incorrectly) not return Object[] (see 6260652)
    if (elementData.getClass() != Object[].class)
        elementData = Arrays.copyOf(elementData, size, Object[].class);
} 
</code></pre><h4 id="2-3-新增"><a href="#2-3-新增" class="headerlink" title="2.3 新增"></a>2.3 新增</h4><p>ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、set(int index, E element)这个五个方法来实现ArrayList增加。</p>
<p> <strong>add(E e)</strong>：将指定的元素添加到此列表的尾部。 </p>
<pre><code> public boolean add(E e) {
ensureCapacity(size + 1);  // Increments modCount!!
elementData[size++] = e;
return true;
} 
</code></pre><p>  这里ensureCapacity()方法是对ArrayList集合进行扩容操作，elementData(size++) = e，将列表末尾元素指向e。 </p>
<p> <strong>add(int index, E element)</strong>：将指定的元素插入此列表中的指定位置。 </p>
<pre><code>public void add(int index, E element) {
  //判断索引位置是否正确
  if (index &gt; size || index &lt; 0)
      throw new IndexOutOfBoundsException(
      &quot;Index: &quot;+index+&quot;, Size: &quot;+size);
  //扩容检测
  ensureCapacity(size+1);  
  /*
   * 对源数组进行复制处理（位移），从index + 1到size-index。
   * 主要目的就是空出index位置供数据插入，
   * 即向右移动当前位于该位置的元素以及所有后续元素。 
   */
  System.arraycopy(elementData, index, elementData, index + 1,
           size - index);
  //在指定位置赋值
  elementData[index] = element;
  size++;
  } 
</code></pre><p> 在这个方法中最根本的方法就是System.arraycopy()方法，该方法的根本目的就是将index位置空出来以供新数据插入，这里需要进行数组数据的右移，这是非常麻烦和耗时的，所以如果指定的数据集合需要进行大量插入（中间插入）操作，推荐使用LinkedList。 </p>
<p> <strong>addAll(Collection&lt;? extends E&gt; c)</strong>：按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</p>
<pre><code>public boolean addAll(Collection&lt;? extends E&gt; c) {
    // 将集合C转换成数组
    Object[] a = c.toArray();
    int numNew = a.length;
    // 扩容处理，大小为size + numNew
    ensureCapacity(size + numNew); // Increments modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}
</code></pre><p>   这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法。该方法的原型为：public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。 </p>
<p>   <strong>addAll(int index, Collection&lt;? extends E&gt; c)</strong>：从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。</p>
<pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    //判断位置是否正确
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot;
                + size);
    //转换成数组
    Object[] a = c.toArray();
    int numNew = a.length;
    //ArrayList容器扩容处理
    ensureCapacity(size + numNew); // Increments modCount
    //ArrayList容器数组向右移动的位置
    int numMoved = size - index;
    //如果移动位置大于0，则将ArrayList容器的数据向右移动numMoved个位置，确保增加的数据能够增加
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                numMoved);
    //添加数组
    System.arraycopy(a, 0, elementData, index, numNew);
    //容器容量变大
    size += numNew;   
    return numNew != 0;
} 
</code></pre><p> <strong>set(int index, E element)</strong>：用指定的元素替代此列表中指定位置上的元素。</p>
<pre><code>public E set(int index, E element) {
    //检测插入的位置是否越界
    RangeCheck(index);

    E oldValue = (E) elementData[index];
    //替代
    elementData[index] = element;
    return oldValue;
} 
</code></pre><h4 id="2-4-删除"><a href="#2-4-删除" class="headerlink" title="2.4 删除"></a>2.4 删除</h4><p>ArrayList提供了remove(int index)、remove(Object o)、removeRange(int fromIndex, int toIndex)、removeAll()四个方法进行元素的删除。</p>
<p><strong>remove(int index)</strong>：移除此列表中指定位置上的元素。</p>
<pre><code>public E remove(int index) {
    //位置验证
    RangeCheck(index);

    modCount++;
    //需要删除的元素
    E oldValue = (E) elementData[index];   
    //向左移的位数
    int numMoved = size - index - 1;
    //若需要移动，则想左移动numMoved位
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index + 1, elementData, index,
                numMoved);
    //置空最后一个元素
    elementData[--size] = null; // Let gc do its work

    return oldValue;
} 
</code></pre><p><strong>remove(Object o)</strong>：移除此列表中首次出现的指定元素（如果存在）。</p>
<pre><code>public boolean remove(Object o) {
    //因为ArrayList中允许存在null，所以需要进行null判断
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                //移除这个位置的元素
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
} 
</code></pre><p>其中fastRemove()方法用于移除指定位置的元素。如下</p>
<pre><code>private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // Let gc do its work
}
</code></pre><p> <strong>removeRange(int fromIndex, int toIndex)</strong>：移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</p>
<pre><code>protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;
    System
            .arraycopy(elementData, toIndex, elementData, fromIndex,
                    numMoved);

    // Let gc do its work
    int newSize = size - (toIndex - fromIndex);
    while (size != newSize)
        elementData[--size] = null;
}
</code></pre><p>  removeAll()：是继承自AbstractCollection的方法，ArrayList本身并没有提供实现。</p>
<pre><code>public boolean removeAll(Collection&lt;?&gt; c) {
    boolean modified = false;
    Iterator&lt;?&gt; e = iterator();
    while (e.hasNext()) {
        if (c.contains(e.next())) {
            e.remove();
            modified = true;
        }
    }
    return modified;
} 
</code></pre><h4 id="2-5-查找"><a href="#2-5-查找" class="headerlink" title="2.5 查找"></a>2.5 查找</h4><p>ArrayList提供了get(int index)用读取ArrayList中的元素。由于ArrayList是动态数组，所以我们完全可以根据下标来获取ArrayList中的元素，而且速度还比较快，故ArrayList长于随机访问。</p>
<pre><code>public E get(int index) {
    RangeCheck(index);
   return (E) elementData[index];
}
</code></pre><h4 id="2-6-扩容"><a href="#2-6-扩容" class="headerlink" title="2.6 扩容"></a>2.6 扩容</h4><p>在上面的新增方法的源码中我们发现每个方法中都存在这个方法：ensureCapacity()，该方法就是ArrayList的扩容方法。在前面就提过ArrayList每次新增元素时都会需要进行容量检测判断，若新增元素后元素的个数会超过ArrayList的容量，就会进行扩容操作来满足新增元素的需求。所以当我们清楚知道业务数据量或者需要插入大量元素前，我可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<pre><code>public void ensureCapacity(int minCapacity) {
    //修改计时器
    modCount++;
    //ArrayList容量大小
    int oldCapacity = elementData.length;
    /*
     * 若当前需要的长度大于当前数组的长度时，进行扩容操作
     */
    if (minCapacity &gt; oldCapacity) {
        Object oldData[] = elementData;
        //计算新的容量大小，为当前容量的1.5倍
        int newCapacity = (oldCapacity * 3) / 2 + 1;
        if (newCapacity &lt; minCapacity)
            newCapacity = minCapacity;
        //数组拷贝，生成新的数组
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}
</code></pre><p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p>
<p>  处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过<strong>trimToSize()</strong>方法来实现。该方法可以最小化ArrayList实例的存储量。 </p>
<pre><code>public void trimToSize() {
    modCount++;
    int oldCapacity = elementData.length;
    if (size &lt; oldCapacity) {
        elementData = Arrays.copyOf(elementData, size);
    }
}
</code></pre>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/JoshuaAstrayPW" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 Joshua<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>